/**
 * Blog Posts - Combined Static + Shopify Data
 * 
 * This module combines:
 * 1. Static blog posts (hardcoded for SEO and initial content)
 * 2. Dynamic posts from Shopify Blog API (generated by blog researcher)
 */

import { BlogPost } from './types';
import { blogPosts } from './posts';
import { bestOfPosts } from './best-of-posts';
import { problemsPosts } from './problems-posts';
import { getAllShopifyBlogArticles, getShopifyBlogArticle } from '../shopify/blog';

// Cache for Shopify articles
let shopifyArticlesCache: BlogPost[] | null = null;
let cacheTimestamp: number = 0;
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

/**
 * Get all static posts (from hardcoded files)
 */
export function getStaticPosts(): BlogPost[] {
  return [...blogPosts, ...bestOfPosts, ...problemsPosts];
}

/**
 * Get all posts (static + Shopify)
 * For server components only
 */
export async function getAllPostsAsync(): Promise<BlogPost[]> {
  const staticPosts = getStaticPosts();
  
  try {
    // Check cache
    if (shopifyArticlesCache && Date.now() - cacheTimestamp < CACHE_TTL) {
      const combined = [...staticPosts, ...shopifyArticlesCache];
      return deduplicateAndSort(combined);
    }
    
    // Fetch from Shopify
    const shopifyPosts = await getAllShopifyBlogArticles();
    
    // Update cache
    shopifyArticlesCache = shopifyPosts;
    cacheTimestamp = Date.now();
    
    const combined = [...staticPosts, ...shopifyPosts];
    return deduplicateAndSort(combined);
  } catch (error) {
    console.error('[Blog] Error fetching Shopify articles:', error);
    // Fallback to static posts only
    return staticPosts.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
  }
}

/**
 * Get featured posts (static + Shopify)
 */
export async function getFeaturedPostsAsync(): Promise<BlogPost[]> {
  const allPosts = await getAllPostsAsync();
  return allPosts.filter(post => post.featured);
}

/**
 * Get post by slug (static + Shopify)
 */
export async function getPostBySlugAsync(slug: string): Promise<BlogPost | null> {
  // First check static posts
  const staticPosts = getStaticPosts();
  const staticPost = staticPosts.find(post => post.slug === slug);
  
  if (staticPost) {
    return staticPost;
  }
  
  // Then check Shopify
  try {
    const shopifyPost = await getShopifyBlogArticle(slug);
    return shopifyPost;
  } catch (error) {
    console.error('[Blog] Error fetching Shopify article:', error);
    return null;
  }
}

/**
 * Get posts by category
 */
export async function getPostsByCategoryAsync(category: string): Promise<BlogPost[]> {
  const allPosts = await getAllPostsAsync();
  return allPosts.filter(post => post.category === category);
}

/**
 * Get related posts
 */
export async function getRelatedPostsAsync(currentSlug: string, limit: number = 3): Promise<BlogPost[]> {
  const allPosts = await getAllPostsAsync();
  const currentPost = allPosts.find(post => post.slug === currentSlug);
  
  if (!currentPost) return [];
  
  return allPosts
    .filter(post => post.slug !== currentSlug)
    .filter(post => 
      post.category === currentPost.category ||
      post.tags.some(tag => currentPost.tags.includes(tag))
    )
    .slice(0, limit);
}

/**
 * Deduplicate posts by slug and sort by date
 */
function deduplicateAndSort(posts: BlogPost[]): BlogPost[] {
  const seen = new Set<string>();
  const unique: BlogPost[] = [];
  
  for (const post of posts) {
    if (!seen.has(post.slug)) {
      seen.add(post.slug);
      unique.push(post);
    }
  }
  
  return unique.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());
}

// Re-export types
export type { BlogPost } from './types';
export { BLOG_CATEGORIES } from './types';
