/**
 * Parser for AI-generated descriptionHtml
 * 
 * Extracts structured data (pros, cons, FAQs, description) from the HTML
 * generated by Claude during product enrichment.
 */

export interface ParsedDescription {
  mainDescription: string | null;
  pros: string[];
  cons: string[];
  accessories: string[];
  faqs: { question: string; answer: string }[];
  isAiEnriched: boolean;
  confidenceLevel: string | null;
}

/**
 * Parse the AI-generated descriptionHtml to extract structured data
 */
export function parseDescriptionHtml(html: string | null | undefined): ParsedDescription {
  const result: ParsedDescription = {
    mainDescription: null,
    pros: [],
    cons: [],
    accessories: [],
    faqs: [],
    isAiEnriched: false,
    confidenceLevel: null,
  };

  if (!html) {
    return result;
  }

  // Check if this is AI-enriched content (has our specific structure)
  if (!html.includes('product-description') && !html.includes('pros-cons')) {
    return result;
  }

  result.isAiEnriched = true;

  try {
    // Extract main description from description-intro
    const descMatch = html.match(/<div class="description-intro"[^>]*>[\s\S]*?<p[^>]*>([\s\S]*?)<\/p>/i);
    if (descMatch) {
      result.mainDescription = cleanText(descMatch[1]);
    }

    // Extract pros
    const prosMatch = html.match(/<div class="pros"[^>]*>[\s\S]*?<ul>([\s\S]*?)<\/ul>/i);
    if (prosMatch) {
      const prosItems = prosMatch[1].match(/<li[^>]*>([\s\S]*?)<\/li>/gi);
      if (prosItems) {
        result.pros = prosItems.map(item => {
          const text = item.replace(/<\/?li[^>]*>/gi, '');
          return cleanText(text);
        }).filter(Boolean);
      }
    }

    // Extract cons
    const consMatch = html.match(/<div class="cons"[^>]*>[\s\S]*?<ul>([\s\S]*?)<\/ul>/i);
    if (consMatch) {
      const consItems = consMatch[1].match(/<li[^>]*>([\s\S]*?)<\/li>/gi);
      if (consItems) {
        result.cons = consItems.map(item => {
          const text = item.replace(/<\/?li[^>]*>/gi, '');
          return cleanText(text);
        }).filter(Boolean);
      }
    }

    // Extract accessories
    const accessoriesMatch = html.match(/<div class="accessories-section"[^>]*>[\s\S]*?<ul>([\s\S]*?)<\/ul>/i);
    if (accessoriesMatch) {
      const accessoryItems = accessoriesMatch[1].match(/<li[^>]*>([\s\S]*?)<\/li>/gi);
      if (accessoryItems) {
        result.accessories = accessoryItems.map(item => {
          const text = item.replace(/<\/?li[^>]*>/gi, '');
          return cleanText(text);
        }).filter(Boolean);
      }
    }

    // Extract FAQs
    const faqSection = html.match(/<div class="faq-section"[^>]*>([\s\S]*?)<\/div>\s*<p class="content-note"/i);
    if (faqSection) {
      const faqItems = faqSection[1].match(/<div class="faq-item"[^>]*>([\s\S]*?)<\/div>\s*<\/div>/gi);
      if (faqItems) {
        result.faqs = faqItems.map(item => {
          const questionMatch = item.match(/<h4[^>]*>([\s\S]*?)<\/h4>/i);
          const answerMatch = item.match(/<p itemprop="text">([\s\S]*?)<\/p>/i);
          
          if (questionMatch && answerMatch) {
            return {
              question: cleanText(questionMatch[1]),
              answer: cleanText(answerMatch[1]),
            };
          }
          return null;
        }).filter((faq): faq is { question: string; answer: string } => faq !== null);
      }
    }

    // Extract confidence level
    const confidenceMatch = html.match(/confidence-badge[^>]*>([^<]+)</i);
    if (confidenceMatch) {
      result.confidenceLevel = cleanText(confidenceMatch[1]);
    }

  } catch (error) {
    console.error('Error parsing descriptionHtml:', error);
  }

  return result;
}

/**
 * Clean text by removing HTML tags, extra whitespace, and markdown formatting
 */
function cleanText(text: string): string {
  return text
    // Remove HTML tags
    .replace(/<[^>]*>/g, '')
    // Remove markdown bold
    .replace(/\*\*([^*]+)\*\*/g, '$1')
    // Normalize whitespace
    .replace(/\s+/g, ' ')
    // Trim
    .trim();
}

/**
 * Check if a product has AI-enriched content
 */
export function hasAiEnrichedContent(html: string | null | undefined): boolean {
  if (!html) return false;
  return html.includes('product-description') && html.includes('pros-cons');
}
